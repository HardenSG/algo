# 链表节点两两交换

![节点两两交换](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

节点交换的思路可以分为递归和非递归两种类型
该题目不像翻转链表问题的最小单元为单个节点

该题目的递归解法有点难以考虑

## 递归思路

1. 获取到当前节点的next节点（这就是交换节点的后一个节点）
2. 当前节点的next指向为递归函数的结果
3. 这时可以走向递归函数的逻辑，递归函数最后终止的节点会停留在倒数第二个节点，最后一个递归结束会返回null
4. 这时倒数第二个节点的next指向就指向了null
5. next变量存储的是当前倒数第二个节点的next节点，将这个next指向当前的节点，因此此操作后就实现了节点的位置交换
6. 然后返回next节点，这个返回的就是交换后的这个子序列(无论与否，一定是排好且交换过或者不需要交换后的子序列)，此时退出该栈
7. 进入上一层的递归函数停滞点也就是head.next = swapPairs(next.next) ，此时这个递归函数返回的是上一个子序列也就是交换位置后的结构
8. 如此往复

## 举例

> 以链表`[1,2,3,4,5]`为例

1. 第一次next拿到了2
2. head.next也就是1的next指向了递归的函数（停滞1），并且将next.next作为了引用传递，传递的值为3
3. 第二次调用next拿到了3的next也就是4
4. head.next也就是3的next指向了递归的函数（停滞2），并且将next.next作为了引用传递，传递的值为5
5. 符合5.next == null，停滞2结束，因此停滞2的结果返回为5，所以head.next也就是3的next指向了5
6. 然后next.next也就是4.next指向了head也就是4指向了3这个序列（这是排好序且交换过位置的了）
7. 然后返回next，这时候停滞一结束返回的值为next也就是4这个序列
8. head.next也就是1的next指向了4这个序列
9. next.next也就是2.next指向了head就是1及其后面的子序列
10. 然后返回next也就是2开头的链表，此时函数调用结束

## 思考

   递归函数往往都需要将问题细化分为最小单元考虑，递归的函数有的时候理解起来难度不是特别高，经过一番思考或者调试也能理解出是为什么
但是就是写起来没有思路，在编写递归函数的时候需要考虑，递归结束的边界是什么、递归函数如果组合子问题、如何将大的问题分解为小问题

以这道题举例：

1. 大问题就是我需要将这个链表中的每个节点进行两两交换位置
小问题就是两两交换位置

2. 那么我就需要考虑，递归函数如何才能保证每次递归的范围是两个元素而不是一个一个元素进行的
3. 这个时候并不是通过控制结束的边界条件，边界条件只是递归的结束条件，如果调用的传参不合理，也不能达到需求。
4. 在调用递归函数的时候提前将递归的范围确定，就像这道题swapPairs(next.next)递归的范围就是当前节点的下下个节点，所以它的范围就是两个节点。所以就能保证递归的范围是两两交换，如果链表元素的个数是奇数个，那么在调用next.next的时候就会由于边界条件而返回了
5. 像这道题来说，小问题是交换节点的位置，那么我先解决小问题，如何进行交换，我需要将当前节点的next节点指向为next节点的next也就是下下个节点，再把当前节点的next指向当前节点，也就是两两交换就是相当于交换节点的next，那么需要解决的问题就是如何确保当前节点的下下个节点的序列是已经处理好的，因此就需要先递归确保从最后一个范围的元素已经被处理，才能使当前节点的next轻松指向一个已经处理好的序列。处理的操作就是写在递归函数后的操作
6. 所以对递归的结束条件和每个子问题对当前节点的处理都是非常重要的，比如对于这道题目来说，最后停滞的节点是3，经过递归之后也就是5返回的就是5这个节点，因为已经被递归函数触碰到边界返回了。那么在3的节点中就将3的next指向5，4的next指向3，然后返回4 -> [4, 3, 5]
7. 这样4就是一个已经处理好的序列退回到上一帧，也就是当前节点为1，如此将1的next指向4将2的next指向1，此时序列为[2, 1, 4, 3, 5]然后将next也就是2返回
8. 在处理了子问题的同时（递归解决处理序列的问题）也就解决了大问题合并小问题的问题
9. 因此递归就是考虑如何处理小问题，在这个过程中就能解决问题的合并
